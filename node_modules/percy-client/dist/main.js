'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var http = require('http');
var https = require('https');
var utils = require('./utils');
var Environment = require('./environment');
var UserAgent = require('./user-agent');
var retry = require('bluebird-retry');
var requestPromise = require('request-promise');
var PromisePool = require('es6-promise-pool');
var regeneratorRuntime = require('regenerator-runtime'); // eslint-disable-line no-unused-vars
var fs = require('fs');

require('dotenv').config();

var RETRY_ERROR_CODES = ['ECONNRESET', 'ECONNREFUSED', 'EPIPE', 'EHOSTUNREACH', 'EAI_AGAIN'];
var JSON_API_CONTENT_TYPE = 'application/vnd.api+json';
var CONCURRENCY = 2;

function retryPredicate(err) {
  if (err.statusCode) {
    return err.statusCode >= 500 && err.statusCode < 600;
  } else if (err.error && !!err.error.code) {
    return RETRY_ERROR_CODES.includes(err.error.code);
  } else {
    return false;
  }
}

var Resource = function () {
  function Resource(options) {
    _classCallCheck(this, Resource);

    if (!options.resourceUrl) {
      throw new Error('"resourceUrl" arg is required to create a Resource.');
    }
    if (!options.sha && !options.content) {
      throw new Error('Either "sha" or "content" is required to create a Resource.');
    }
    if (/\s/.test(options.resourceUrl)) {
      throw new Error('"resourceUrl" arg includes whitespace. It needs to be encoded.');
    }
    this.resourceUrl = options.resourceUrl;
    this.content = options.content;
    this.sha = options.sha || utils.sha256hash(options.content);
    this.mimetype = options.mimetype;
    this.isRoot = options.isRoot;

    // Temporary convenience attributes, will not be serialized. These are used, for example,
    // to hold the local path so reading file contents can be deferred.
    this.localPath = options.localPath;
  }

  _createClass(Resource, [{
    key: 'serialize',
    value: function serialize() {
      return {
        type: 'resources',
        id: this.sha,
        attributes: {
          'resource-url': this.resourceUrl,
          mimetype: this.mimetype || null,
          'is-root': this.isRoot || null
        }
      };
    }
  }]);

  return Resource;
}();

var PercyClient = function () {
  function PercyClient(options) {
    _classCallCheck(this, PercyClient);

    options = options || {};
    this.token = options.token;
    this.apiUrl = options.apiUrl || 'https://percy.io/api/v1';
    this.environment = options.environment || new Environment(process.env);
    this._httpClient = requestPromise;
    this._httpModule = this.apiUrl.indexOf('http://') === 0 ? http : https;
    // A custom HttpAgent with pooling and keepalive.
    this._httpAgent = new this._httpModule.Agent({
      maxSockets: 5,
      keepAlive: true
    });
    this._clientInfo = options.clientInfo;
    this._environmentInfo = options.environmentInfo;
    this._sdkClientInfo = null;
    this._sdkEnvironmentInfo = null;
  }

  _createClass(PercyClient, [{
    key: '_headers',
    value: function _headers(headers) {
      return _extends({
        Authorization: 'Token token=' + this.token,
        'User-Agent': new UserAgent(this).toString()
      }, headers);
    }
  }, {
    key: '_httpGet',
    value: function _httpGet(uri) {
      var requestOptions = {
        method: 'GET',
        uri: uri,
        headers: this._headers(),
        json: true,
        resolveWithFullResponse: true,
        agent: this._httpAgent
      };

      return retry(this._httpClient, {
        context: this,
        args: [uri, requestOptions],
        interval: 50,
        max_tries: 5,
        throw_original: true,
        predicate: retryPredicate
      });
    }
  }, {
    key: '_httpPost',
    value: function _httpPost(uri, data) {
      var requestOptions = {
        method: 'POST',
        uri: uri,
        body: data,
        headers: this._headers({ 'Content-Type': JSON_API_CONTENT_TYPE }),
        json: true,
        resolveWithFullResponse: true,
        agent: this._httpAgent
      };

      return retry(this._httpClient, {
        context: this,
        args: [uri, requestOptions],
        interval: 50,
        max_tries: 5,
        throw_original: true,
        predicate: retryPredicate
      });
    }
  }, {
    key: 'createBuild',
    value: function createBuild(options) {
      var parallelNonce = this.environment.parallelNonce;
      var parallelTotalShards = this.environment.parallelTotalShards;

      // Only pass parallelism data if it all exists.
      if (!parallelNonce || !parallelTotalShards) {
        parallelNonce = null;
        parallelTotalShards = null;
      }

      options = options || {};

      var commitData = options['commitData'] || this.environment.commitData;

      var data = {
        data: {
          type: 'builds',
          attributes: {
            branch: commitData.branch,
            'target-branch': this.environment.targetBranch,
            'target-commit-sha': this.environment.targetCommitSha,
            'commit-sha': commitData.sha,
            'commit-committed-at': commitData.committedAt,
            'commit-author-name': commitData.authorName,
            'commit-author-email': commitData.authorEmail,
            'commit-committer-name': commitData.committerName,
            'commit-committer-email': commitData.committerEmail,
            'commit-message': commitData.message,
            'pull-request-number': this.environment.pullRequestNumber,
            'parallel-nonce': parallelNonce,
            'parallel-total-shards': parallelTotalShards,
            partial: this.environment.partialBuild
          }
        }
      };

      if (options.resources) {
        data['data']['relationships'] = {
          resources: {
            data: options.resources.map(function (resource) {
              return resource.serialize();
            })
          }
        };
      }

      return this._httpPost(this.apiUrl + '/builds/', data);
    }

    // This method is unavailable to normal write-only project tokens.

  }, {
    key: 'getBuild',
    value: function getBuild(buildId) {
      return this._httpGet(this.apiUrl + '/builds/' + buildId);
    }

    // This method is unavailable to normal write-only project tokens.

  }, {
    key: 'getBuilds',
    value: function getBuilds(project, filter) {
      filter = filter || {};
      var queryString = Object.keys(filter).map(function (key) {
        if (Array.isArray(filter[key])) {
          // If filter value is an array, match Percy API's format expectations of:
          //   filter[key][]=value1&filter[key][]=value2
          return filter[key].map(function (array_value) {
            return 'filter[' + key + '][]=' + array_value;
          }).join('&');
        } else {
          return 'filter[' + key + ']=' + filter[key];
        }
      }).join('&');

      if (queryString.length > 0) {
        queryString = '?' + queryString;
      }

      return this._httpGet(this.apiUrl + '/projects/' + project + '/builds' + queryString);
    }
  }, {
    key: 'makeResource',
    value: function makeResource(options) {
      return new Resource(options);
    }

    // Synchronously walks a directory of compiled assets and returns an array of Resource objects.

  }, {
    key: 'gatherBuildResources',
    value: function gatherBuildResources(rootDir, options) {
      return utils.gatherBuildResources(this, rootDir, options);
    }
  }, {
    key: 'uploadResource',
    value: function uploadResource(buildId, content) {
      var sha = utils.sha256hash(content);
      var data = {
        data: {
          type: 'resources',
          id: sha,
          attributes: {
            'base64-content': utils.base64encode(content)
          }
        }
      };

      return this._httpPost(this.apiUrl + '/builds/' + buildId + '/resources/', data);
    }
  }, {
    key: 'uploadResources',
    value: function uploadResources(buildId, resources) {
      var _marked = /*#__PURE__*/regeneratorRuntime.mark(generatePromises);

      var _this = this;
      function generatePromises() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, resource, content;

        return regeneratorRuntime.wrap(function generatePromises$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context.prev = 3;
                _iterator = resources[Symbol.iterator]();

              case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context.next = 13;
                  break;
                }

                resource = _step.value;
                content = resource.localPath ? fs.readFileSync(resource.localPath) : resource.content;
                _context.next = 10;
                return _this.uploadResource(buildId, content);

              case 10:
                _iteratorNormalCompletion = true;
                _context.next = 5;
                break;

              case 13:
                _context.next = 19;
                break;

              case 15:
                _context.prev = 15;
                _context.t0 = _context['catch'](3);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 19:
                _context.prev = 19;
                _context.prev = 20;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 22:
                _context.prev = 22;

                if (!_didIteratorError) {
                  _context.next = 25;
                  break;
                }

                throw _iteratorError;

              case 25:
                return _context.finish(22);

              case 26:
                return _context.finish(19);

              case 27:
              case 'end':
                return _context.stop();
            }
          }
        }, _marked, this, [[3, 15, 19, 27], [20,, 22, 26]]);
      }

      var pool = new PromisePool(generatePromises(), CONCURRENCY);
      return pool.start();
    }
  }, {
    key: 'uploadMissingResources',
    value: function uploadMissingResources(buildId, response, resources) {
      var missingResourceShas = utils.getMissingResources(response);
      if (!missingResourceShas.length) {
        return Promise.resolve();
      }

      var resourcesBySha = resources.reduce(function (map, resource) {
        map[resource.sha] = resource;
        return map;
      }, {});
      var missingResources = missingResourceShas.map(function (resource) {
        return resourcesBySha[resource.id];
      });

      return this.uploadResources(buildId, missingResources);
    }
  }, {
    key: 'createSnapshot',
    value: function createSnapshot(buildId, resources, options) {
      options = options || {};
      resources = resources || [];

      var data = {
        data: {
          type: 'snapshots',
          attributes: {
            name: options.name || null,
            'enable-javascript': options.enableJavaScript || null,
            widths: options.widths || null,
            'minimum-height': options.minimumHeight || null
          },
          relationships: {
            resources: {
              data: resources.map(function (resource) {
                return resource.serialize();
              })
            }
          }
        }
      };

      this._sdkClientInfo = options.clientInfo;
      this._sdkEnvironmentInfo = options.environmentInfo;
      return this._httpPost(this.apiUrl + '/builds/' + buildId + '/snapshots/', data);
    }
  }, {
    key: 'finalizeSnapshot',
    value: function finalizeSnapshot(snapshotId) {
      return this._httpPost(this.apiUrl + '/snapshots/' + snapshotId + '/finalize', {});
    }
  }, {
    key: 'finalizeBuild',
    value: function finalizeBuild(buildId, options) {
      options = options || {};
      var allShards = options.allShards || false;
      var query = allShards ? '?all-shards=true' : '';
      return this._httpPost(this.apiUrl + '/builds/' + buildId + '/finalize' + query, {});
    }
  }]);

  return PercyClient;
}();

module.exports = PercyClient;